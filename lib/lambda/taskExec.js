/* eslint-disable no-underscore-dangle */

const fs = require('fs')
const os = require('os')
const path = require('path')
const promisify = require('util-promisify')

const { TaskError } = require('./taskDef')

const readFile = promisify(fs.readFile)
const unlink = promisify(fs.unlink)
const writeFile = promisify(fs.writeFile)

module.exports = run =>
  /**
   * Run a load test given an Artillery script and report the results
   * @param timeNow The time this task invocation began (serves as an id for the function)
   * @param script The artillery script to execution load from
   * @returns {Promise} Resolving to the load results report generated by Artillery
   */
  (timeNow, script) => {
    if (script._simulation) return Promise.resolve({ Payload: '{ "errors": 0 }' })

    const scriptPath = path.resolve(os.tmpdir(), 'script.json')
    const outputPath = path.resolve(os.tmpdir(), 'output.json')

    return writeFile(scriptPath, JSON.stringify(script))
      .then(() => new Promise((resolve, reject) => {
        // Since Artillery will call process.exit() upon termination,
        // we monkey-patch it to load result and resolve/reject the Promise.
        const exit = process.exit

        process.exit = (code) => {
          process.exit = exit // Unpatch
          console.log('Artillery done.')

          if (code === 0) {
            resolve()
          } else {
            reject(new TaskError(`Artillery exited with non-zero code: ${code}`))
          }
        }

        console.log('Starting Artillery...')
        run(scriptPath, { output: outputPath })
      }))
      .then(() => readFile(outputPath, 'utf8'))
      .then(results => unlink(scriptPath)
        .then(() => unlink(outputPath))
        .then(() => JSON.parse(results)))
      .catch((ex) => {
        const msg = `ERROR exception encountered while executing load from ${script._genesis} in ${timeNow}: ${ex.message}\n${ex.stack}`
        console.error(msg)
        throw new TaskError(msg)
      })
  }
